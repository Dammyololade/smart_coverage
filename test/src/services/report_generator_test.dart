import 'dart:convert';
import 'dart:io';

import 'package:smart_coverage/src/models/models.dart';
import 'package:smart_coverage/src/services/services.dart';
import 'package:test/test.dart';

void main() {
  group('ReportGeneratorImpl', () {
    late ReportGenerator reportGenerator;
    late Directory tempDir;
    late CoverageData mockCoverageData;
    late SmartCoverageConfig mockConfig;

    setUp(() async {
      reportGenerator = const ReportGeneratorImpl();
      tempDir = await Directory.systemTemp.createTemp('report_generator_test');

      // Create mock coverage data
      mockCoverageData = const CoverageData(
        files: [
          FileCoverage(
            path: 'lib/smart_coverage.dart',
            lines: [
              LineCoverage(lineNumber: 1, hitCount: 1),
              LineCoverage(lineNumber: 2, hitCount: 1),
              LineCoverage(lineNumber: 5, hitCount: 1),
              LineCoverage(lineNumber: 7, hitCount: 0),
              LineCoverage(lineNumber: 10, hitCount: 0),
            ],
            summary: CoverageSummary(
              linesFound: 5,
              linesHit: 3,
              functionsFound: 2,
              functionsHit: 1,
              branchesFound: 2,
              branchesHit: 1,
            ),
          ),
          FileCoverage(
            path: 'lib/src/version.dart',
            lines: [
              LineCoverage(lineNumber: 1, hitCount: 1),
              LineCoverage(lineNumber: 2, hitCount: 1),
              LineCoverage(lineNumber: 3, hitCount: 1),
            ],
            summary: CoverageSummary(
              linesFound: 3,
              linesHit: 3,
              functionsFound: 1,
              functionsHit: 1,
              branchesFound: 0,
              branchesHit: 0,
            ),
          ),
        ],
        summary: CoverageSummary(
          linesFound: 8,
          linesHit: 6,
          functionsFound: 3,
          functionsHit: 2,
          branchesFound: 2,
          branchesHit: 1,
        ),
      );

      mockConfig = SmartCoverageConfig(
        packagePath: '/test',
        baseBranch: 'main',
        outputDir: tempDir.path,
        skipTests: false,
        aiInsights: false,
        codeReview: false,
        darkMode: false,
        outputFormats: ['html', 'json', 'console'],
        aiConfig: const AiConfig(provider: 'gemini'),
      );
    });

    tearDown(() async {
      if (await tempDir.exists()) {
        await tempDir.delete(recursive: true);
      }
    });

    group('generateHtmlReport', () {
      test('should generate HTML report with light theme', () async {
        final outputPath = '${tempDir.path}/report';

        await reportGenerator.generateHtmlReport(
          mockCoverageData,
          outputPath,
          darkMode: false,
        );

        expect(await File('$outputPath/index.html').exists(), isTrue);

        final content = await File('$outputPath/index.html').readAsString();
        expect(content, contains('Generated by'));
        expect(content, contains('Line Coverage'));
      });

      test('should generate HTML report with dark theme', () async {
        final outputPath = '${tempDir.path}/dark_report';

        await reportGenerator.generateHtmlReport(
          mockCoverageData,
          outputPath,
        );

        expect(await File('$outputPath/index.html').exists(), isTrue);

        final content = await File('$outputPath/index.html').readAsString();
        expect(content, contains('Generated by'));

        // Check that HTML was generated successfully
        expect(content, contains('Line Coverage'));
      });

      test('should handle empty coverage data', () async {
        final outputPath = '${tempDir.path}/empty_report';
        const emptyCoverageData = CoverageData(
          files: [],
          summary: CoverageSummary(
            linesFound: 0,
            linesHit: 0,
            functionsFound: 0,
            functionsHit: 0,
            branchesFound: 0,
            branchesHit: 0,
          ),
        );

        await reportGenerator.generateHtmlReport(
          emptyCoverageData,
          outputPath,
        );

        expect(await File('$outputPath/index.html').exists(), isTrue);

        final content = await File('$outputPath/index.html').readAsString();
        expect(content, contains('<!DOCTYPE html>'));
        expect(content, contains('No coverage data available'));
      });

      test('should create parent directories if they do not exist', () async {
        final outputPath = '${tempDir.path}/nested/dir/report';

        await reportGenerator.generateHtmlReport(
          mockCoverageData,
          outputPath,
        );

        expect(await File('$outputPath/index.html').exists(), isTrue);
        expect(await Directory('${tempDir.path}/nested/dir').exists(), isTrue);
      });

      test('should include coverage statistics', () async {
        final outputPath = '${tempDir.path}/stats_report';

        await reportGenerator.generateHtmlReport(
          mockCoverageData,
          outputPath,
        );

        final content = await File('$outputPath/index.html').readAsString();

        // Should contain coverage percentages
        expect(content, contains('%')); // Coverage percentages
        expect(content, contains('Line Coverage'));
        expect(content, contains('Function Coverage'));
      });
    });

    group('generateJsonReport', () {
      test('should generate valid JSON report', () async {
        final outputPath = '${tempDir.path}/report.json';

        await reportGenerator.generateJsonReport(
          mockCoverageData,
          outputPath,
        );

        expect(await File(outputPath).exists(), isTrue);

        final content = await File(outputPath).readAsString();

        // Should be valid JSON
        expect(() => jsonDecode(content), returnsNormally);

        final jsonData = jsonDecode(content) as Map<String, dynamic>;
        expect(jsonData, containsPair('timestamp', isA<String>()));
        expect(jsonData, containsPair('summary', isA<Map<String, dynamic>>()));
        expect(jsonData, containsPair('files', isA<List<dynamic>>()));

        final files = jsonData['files'] as List;
        expect(files, hasLength(2));

        final firstFile = files[0] as Map<String, dynamic>;
        expect(
          firstFile,
          containsPair('sourceFile', 'lib/smart_coverage.dart'),
        );
        expect(firstFile, containsPair('functions', isA<List<dynamic>>()));
        expect(firstFile, containsPair('branches', isA<List<dynamic>>()));
        expect(firstFile, containsPair('lines', isA<List<dynamic>>()));
      });

      test('should handle empty coverage data', () async {
        final outputPath = '${tempDir.path}/empty_report.json';

        const emptyCoverageData = CoverageData(
          files: [],
          summary: CoverageSummary(
            linesFound: 0,
            linesHit: 0,
            functionsFound: 0,
            functionsHit: 0,
            branchesFound: 0,
            branchesHit: 0,
          ),
        );

        await reportGenerator.generateJsonReport(
          emptyCoverageData,
          outputPath,
        );

        expect(await File(outputPath).exists(), isTrue);

        final content = await File(outputPath).readAsString();
        final jsonData = jsonDecode(content) as Map<String, dynamic>;

        expect(jsonData['files'], isEmpty);
        expect(jsonData['summary']['totalFiles'], equals(0));
      });

      test('should include accurate summary statistics', () async {
        final outputPath = '${tempDir.path}/summary_report.json';

        await reportGenerator.generateJsonReport(
          mockCoverageData,
          outputPath,
        );

        final content = await File(outputPath).readAsString();
        final jsonData = jsonDecode(content) as Map<String, dynamic>;
        final summary = jsonData['summary'] as Map<String, dynamic>;

        expect(summary['totalFiles'], equals(2));
        expect(summary['totalLines'], equals(8)); // 5 + 3 lines
        expect(summary['coveredLines'], equals(6)); // Lines with hitCount > 0
        expect(summary['totalFunctions'], equals(3)); // From mock data summary
        expect(
          summary['coveredFunctions'],
          equals(2),
        ); // From mock data summary
        expect(summary['totalBranches'], equals(2));
        expect(summary['coveredBranches'], equals(1)); // From mock data summary
      });
    });

    group('generateLcovReport', () {
      test('should generate valid LCOV format', () async {
        final outputPath = '${tempDir.path}/report.lcov';

        await reportGenerator.generateLcovReport(
          mockCoverageData,
          outputPath,
        );

        expect(await File(outputPath).exists(), isTrue);

        final content = await File(outputPath).readAsString();

        // Check LCOV format markers
        expect(content, contains('TN:'));
        expect(content, contains('SF:lib/smart_coverage.dart'));
        expect(content, contains('SF:lib/src/version.dart'));
        expect(content, contains('FNF:'));
        expect(content, contains('FNH:'));
        expect(content, contains('BRF:'));
        expect(content, contains('BRH:'));
        expect(content, contains('LF:'));
        expect(content, contains('LH:'));
        expect(content, contains('end_of_record'));
      });

      test('should format function data correctly', () async {
        final outputPath = '${tempDir.path}/functions.lcov';

        await reportGenerator.generateLcovReport(
          mockCoverageData,
          outputPath,
        );

        final content = await File(outputPath).readAsString();

        // Check function summary data
        expect(content, contains('FNF:2')); // Functions found in main.dart
        expect(content, contains('FNH:1')); // Functions hit in main.dart
        expect(content, contains('FNF:1')); // Functions found in utils.dart
        expect(content, contains('FNH:1')); // Functions hit in utils.dart
      });

      test('should format branch data correctly', () async {
        final outputPath = '${tempDir.path}/branches.lcov';

        await reportGenerator.generateLcovReport(
          mockCoverageData,
          outputPath,
        );

        final content = await File(outputPath).readAsString();

        // Check branch data format
        expect(content, contains('BRF:2')); // Total branches in main.dart
        expect(content, contains('BRH:1')); // Covered branches in main.dart
        expect(content, contains('BRF:0')); // Total branches in utils.dart
        expect(content, contains('BRH:0')); // Covered branches in utils.dart
      });

      test('should format line data correctly', () async {
        final outputPath = '${tempDir.path}/lines.lcov';

        await reportGenerator.generateLcovReport(
          mockCoverageData,
          outputPath,
        );

        final content = await File(outputPath).readAsString();

        // Check line data format
        expect(content, contains('DA:1,1'));
        expect(content, contains('DA:2,1'));
        expect(content, contains('DA:5,1'));
        expect(content, contains('DA:7,0'));
        expect(content, contains('DA:10,0'));
        expect(content, contains('LF:5')); // Total lines in main.dart
        expect(content, contains('LH:3')); // Covered lines in main.dart
      });

      test('should handle empty coverage data', () async {
        final outputPath = '${tempDir.path}/empty.lcov';

        const emptyCoverageData = CoverageData(
          files: [],
          summary: CoverageSummary(
            linesFound: 0,
            linesHit: 0,
            functionsFound: 0,
            functionsHit: 0,
            branchesFound: 0,
            branchesHit: 0,
          ),
        );

        await reportGenerator.generateLcovReport(
          emptyCoverageData,
          outputPath,
        );

        expect(await File(outputPath).exists(), isTrue);

        final content = await File(outputPath).readAsString();
        expect(content.trim(), isEmpty);
      });
    });

    group('generateConsoleOutput', () {
      test('should generate formatted console output', () {
        final output = reportGenerator.generateConsoleOutput(mockCoverageData);

        expect(output, contains('Coverage Summary'));
        expect(output, contains('Files analyzed:'));
        expect(output, contains('lib/smart_coverage.dart'));
        expect(output, contains('Line coverage:'));
        expect(output, contains('75.0%'));
      });

      test('should show coverage statistics', () {
        final output = reportGenerator.generateConsoleOutput(mockCoverageData);

        // Should contain coverage percentages
        expect(output, contains('75.0%')); // Line coverage: 6/8 = 75.0%
        expect(output, contains('66.7%')); // Function coverage: 2/3 = 66.7%
        expect(output, contains('50.0%')); // Branch coverage: 1/2 = 50%
      });

      test('should handle empty coverage data', () {
        const emptyCoverageData = CoverageData(
          files: [],
          summary: CoverageSummary(
            linesFound: 0,
            linesHit: 0,
            functionsFound: 0,
            functionsHit: 0,
            branchesFound: 0,
            branchesHit: 0,
          ),
        );

        final output = reportGenerator.generateConsoleOutput(emptyCoverageData);

        expect(output, contains('Coverage Summary'));
        expect(output, contains('Files analyzed: 0'));
      });

      test('should format file details correctly', () {
        final output = reportGenerator.generateConsoleOutput(mockCoverageData);

        // Should show file-specific coverage
        expect(output, contains('lib/smart_coverage.dart'));
        expect(
          output,
          contains('60.0%'),
        ); // File coverage percentage for smart_coverage.dart (3/5 = 60%)
      });
    });

    group('generateReports', () {
      test('should generate all configured report formats', () async {
        await reportGenerator.generateReports(mockCoverageData, mockConfig);

        // Check that all configured formats were generated
        expect(await File('${tempDir.path}/index.html').exists(), isTrue);
        expect(
          await File('${tempDir.path}/coverage_report.json').exists(),
          isTrue,
        );

        // Console output should be returned but not saved to file
        // This is tested indirectly through the console output tests
      });

      test('should handle single format configuration', () async {
        final singleFormatConfig = mockConfig.copyWith(
          outputFormats: ['html'],
        );

        await reportGenerator.generateReports(
          mockCoverageData,
          singleFormatConfig,
        );

        expect(await File('${tempDir.path}/index.html').exists(), isTrue);
        expect(
          await File('${tempDir.path}/coverage_report.json').exists(),
          isFalse,
        );
      });

      test('should handle LCOV format', () async {
        final lcovConfig = mockConfig.copyWith(
          outputFormats: ['lcov'],
        );

        await reportGenerator.generateReports(mockCoverageData, lcovConfig);

        expect(
          await File('${tempDir.path}/coverage_report.lcov').exists(),
          isTrue,
        );
      });

      test('should handle unknown format gracefully', () async {
        final unknownFormatConfig = mockConfig.copyWith(
          outputFormats: ['unknown'],
        );

        // Should not throw, but ignore unknown format
        expect(
          () => reportGenerator.generateReports(
            mockCoverageData,
            unknownFormatConfig,
          ),
          returnsNormally,
        );
      });

      test('should create output directory if it does not exist', () async {
        final nestedConfig = SmartCoverageConfig(
          packagePath: tempDir.path,
          baseBranch: 'main',
          outputDir: '${tempDir.path}/nested/output',
          skipTests: false,
          aiInsights: false,
          codeReview: false,
          darkMode: false,
          outputFormats: ['html'],
          aiConfig: const AiConfig(provider: 'gemini'),
        );

        await reportGenerator.generateReports(mockCoverageData, nestedConfig);

        expect(
          await Directory('${tempDir.path}/nested/output').exists(),
          isTrue,
        );
      });
    });

    group('performance tests', () {
      test('should handle large coverage data efficiently', () async {
        // Use existing files from the project instead of mock files
        final existingFiles = [
          'lib/smart_coverage.dart',
          'lib/src/command_runner.dart',
          'lib/src/version.dart',
        ];

        // Generate coverage data using real files
        final largeCoverageData = CoverageData(
          files: existingFiles
              .map(
                (filePath) => FileCoverage(
                  path: filePath,
                  lines: List.generate(
                    50,
                    (j) => LineCoverage(
                      lineNumber: j + 1,
                      hitCount: j % 3,
                    ),
                  ),
                  summary: const CoverageSummary(
                    linesFound: 50,
                    linesHit: 33,
                    functionsFound: 10,
                    functionsHit: 5,
                    branchesFound: 5,
                    branchesHit: 2,
                  ),
                ),
              )
              .toList(),
          summary: const CoverageSummary(
            linesFound: 150,
            linesHit: 99,
            functionsFound: 30,
            functionsHit: 15,
            branchesFound: 15,
            branchesHit: 6,
          ),
        );

        final stopwatch = Stopwatch()..start();

        await reportGenerator.generateHtmlReport(
          largeCoverageData,
          '${tempDir.path}/large_report',
        );

        stopwatch.stop();

        // Should complete within reasonable time (adjust threshold as needed)
        expect(stopwatch.elapsedMilliseconds, lessThan(5000)); // 5 seconds
        expect(
          await File('${tempDir.path}/large_report/index.html').exists(),
          isTrue,
        );
      });

      test('should generate console output quickly for large data', () {
        // Generate large coverage data set
        final largeCoverageData = CoverageData(
          files: List.generate(
            1000,
            (index) => FileCoverage(
              path: 'lib/file_$index.dart',
              lines: List.generate(
                100,
                (lineIndex) => LineCoverage(
                  lineNumber: lineIndex + 1,
                  hitCount: lineIndex % 2,
                ),
              ),
              summary: const CoverageSummary(
                linesFound: 100,
                linesHit: 50,
                functionsFound: 10,
                functionsHit: 5,
                branchesFound: 20,
                branchesHit: 10,
              ),
            ),
          ),
          summary: const CoverageSummary(
            linesFound: 100000,
            linesHit: 50000,
            functionsFound: 10000,
            functionsHit: 5000,
            branchesFound: 20000,
            branchesHit: 10000,
          ),
        );

        final stopwatch = Stopwatch()..start();

        final output = reportGenerator.generateConsoleOutput(largeCoverageData);

        stopwatch.stop();

        expect(stopwatch.elapsedMilliseconds, lessThan(1000)); // 1 second
        expect(output, isNotEmpty);
        expect(output, contains('Coverage Summary'));
      });
    });
  });
}
